#!/bin/bash
#
# repmgrd	Start up the repmgrd daemon
#		repmrgd (replication manager daemon)
#
# chkconfig: -  75 16
# description: repmgrd is the repliation manager daemon \
# The repmgrd replication management and monitoring daemon for PostgreSQL.

### BEGIN INIT INFO
# Provides: repmgrd
# Required-Start:  $local_fs $remote_fs $network $syslog postgresql
# Required-Stop:     $local_fs $remote_fs $network $syslog postgresql
# Should-Start:	     $syslog postgresql-9.3
# Should-Stop: $syslog postgresql-9.3
# Short-Description: start and stop repmrgd
# Description: Enable repmgrd replication management and monitoring daemon for PostgreSQL
#	       this is used to monitor a postgresql cluster.
### END INIT INFO

# Source function library.
. /etc/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

prog=repmgrd
REPMGRD_ENABLED=yes
REPMGRD_OPTS=
REPMGRD_USER=postgres

# pull in sysconfig settings
[ -f /etc/sysconfig/repmgrd ] && . /etc/sysconfig/repmgrd

LOCKFILE=/var/lock/subsys/$prog
PIDFILE=/var/run/repmgrd.pid
RETVAL=0

case "$REPMGRD_ENABLED" in
    [Yy]*)
	#nothing to do here	
	;;
    *)
	exit 2
	;;
esac


if [ -z "$REPMGRD_OPTS" ]
then
    echo "Not starting $prog, REPMGRD_OPTS not set in /etc/sysconfig/$prog"
    exit 2
fi


start() {
	[ "$EUID" != "0" ] && exit 4
        [ "$NETWORKING" = "no" ] && exit 1
	checklockfile
	if [ "$RETVAL" == "1" ] ; then
		echo "process is already running."
		return $RETVAL
	fi
        # Start daemons.
        echo -n $"Starting $prog: "
        daemon --user $REPMGRD_USER $prog -d $REPMGRD_OPTS
	checklockfile
	echo $pid > $PIDFILE
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] && touch $LOCKFILE
        return $RETVAL
}

stop() {
	[ "$EUID" != "0" ] && exit 4
        echo -n $"Shutting down $prog: "
        killproc $prog
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] && rm -f $LOCKFILE $PIDFILE
        return $RETVAL
}

function status()
{
	checkpidfile
	if [ "$RETVAL" -eq "0" ]; then
		echo  "${prog} (pid ${kpid}) is running..."
	elif [ "$RETVAL" -eq "1" ]; then
		echo "PID file exists, but process is not running"
	else
		checklockfile
		if [ "$RETVAL" -eq "2" ]; then
			echo "${prog} lockfile exists but process is not running"
		else
			if [ -z "$pid" ]; then
				echo "${prog} is stopped"
				RETVAL="3"
			else
				echo "pidfile missing but ${prog} (pid ${pid}) is running..."
				RETVAL="0"
			fi
		fi
	fi
	return $RETVAL
}

function checklockfile()
{
	pid="$(/usr/bin/pgrep -d , -u ${REPMGRD_USER} ${prog})"
	if [ -z "$pid" ]; then
		if [ -f "$LOCKFILE" ]; then
			# The lockfile exists but the process is not running
			RETVAL="2"
		else
			#lockfile does not exist and process is not running
			RETVAL="0"
		fi
	else
		#process is not running
		RETVAL="1"
	fi
}

function checkpidfile()
{
	if [ -f "${PIDFILE}" ]; then
		read kpid < ${PIDFILE}
		if [ "$kpid" == "" ] ; then
			RETVAL="4"
		elif [ -d "/proc/${kpid}" ]; then
			# pid file exists and the process is running
			RETVAL="0"
		else
			# The pid file exists but the process is not running
			RETVAL="1"
		fi
	else
		# pid file does not exist and program is most likely not running
		RETVAL="3"
	fi
}

# See how we were called.
case "$1" in
  start)
        start
        ;;
  stop)
        stop
        ;;
  status)
        status $prog
        ;;
  restart|force-reload)
        stop
        start
        ;;
  try-restart|condrestart)
        if status $prog > /dev/null; then
            stop
            start
        fi
        ;;
  reload)
        exit 3
        ;;
  *)
        echo $"Usage: $0 {start|stop|status|restart|try-restart|force-reload}"
        exit 2
esac
